# Python 对象引用、可变性和垃圾回收
- 变量是标注，而不是盒子
- 元组是不可改变的，但其中的值可以改变
- 浅复制, 深复制
- 引用和函数参数
- 可变的参数默认值可能导致的问题
- 如何安全的处理函数调用者传入的可变参数
- 垃圾回收， del命令
- 如何运用弱引用‘记住’对象， 而不需要对象本身存在

## 标识，相等性和别名
### ==和is之间选择
  == 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的标识
a == b 是语法糖，等同于 a.__eq__(b)。

### 元组的相对不可变性
  元组与多数python集合一样存的是对象的引用。元组的不可变指保存的引用不可变， 但引用的对象可以变。
  元组和 frozenset

### 浅复制
即复制了最外层容器，副本中的元素仍是源容器中元素的引用. 如果元素都是不可变元素可以做浅复制，
如果元素中存在可变元素最好用深复制。

l1 = [1,2]
l2 = list(l1) 
该复制等价于l2 = l1[:], l2 = l1.copy()做的是浅复制

### 深复制
应用模块copy中的deepcopy,深复制有时可能太深了。例如，对象可能会引用不该复制的外部资源或单例值。
我们可以实现特殊方法 __copy__() 和 __deepcopy__()，控制 copy 和 deepcopy 的行为

### 函数的参数作为引用时
Python 唯一支持的参数传递模式是共享传参。 Java 的引用类型是这样，基本类型按值传参。
函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识（即不能把一个对象替换成另一个对象）
列表，字典都的大部分操作都会影响到通过参数传入的对象。

#### 不要使用可变对象作为参数的默认值

## del语句 ，垃圾回收
del删除的变量保存的是对象的最后一个引用，变量就可以被垃圾回收机制回收。
重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。
在 CPython 中，垃圾回收使用的主要算法是引用计数。

## 回调函数

## 弱引用
- weakref.ref
- weakref.finalize
- WeakValueDictionary 经常用于缓存
- WeakKeyDictionary 经常用于缓存
- WeakSet 经常用于缓存

## 要点总结
- 简单的赋值不创建副本。
- 对 += 或 *= 所做的增量赋值来说，如果左边的变量绑定的是不可变对象，会创建新对象；如果是可变对象，会就地修改
- 为现有的变量赋予新值，不会修改之前绑定的变量。这叫重新绑定：现在变量绑定了其他对象
- 使用可变类型作为函数参数的默认值有危险，因为如果就地修改了参数，默认值也就变了，这会影响以后使用默认值的调用





